import { promises as fs } from 'fs';

import pinataSDK from '@pinata/sdk';
import * as dotenv from "dotenv"; // npm install dotenv
import slugify from 'slugify';

import { galleryPieces } from './config';
import { Nft } from './types';

dotenv.config();

const { PINATA_API_SECRET, PINATA_API_KEY } = process.env;
if (!PINATA_API_SECRET || !PINATA_API_KEY) {
	throw new Error('Missing PINATA_API_SECRET or PINATA_API_KEY in env');
}
const pinata = pinataSDK(PINATA_API_KEY, PINATA_API_SECRET);

const NETWORK_NAMES: Record<string, string> = {
	matic_testnet: "Matic Testnet",
	ropsten: "Ropsten",
	hardhat: "Hardhat",
}

const makeNfts = (cid: string, network: string) => galleryPieces.map(piece => {
	const {
		src,
		title: name,
		artist,
		media,
	} = piece;

	const pathParts = src.split("/");
	const filename = pathParts[pathParts.length - 1];
	const path = src.replace(filename, "");

	const networkName = NETWORK_NAMES[network] || `${network.slice(0, 1).toUpperCase()}${network.slice(1)}`;

	return {
		path,
		filename,
		metadata: {
			name,
			description: `${name} by ${artist}, using ${media}.  This is the initial release of this NFT on ${networkName}.  Released under the NFTL 1.0 license.`,
			attributes: "",
			image: `https://ipfs.infura.io/ipfs/${cid}${src}`,
			external_url: "https://artful.one/gallery",
		},
	} as Nft;
});

async function uploadAndPinNFTDirectory(directory: string, name:string) {
	console.log("Pinning directory", directory);
	return pinata.pinFromFS(
		directory, {
			pinataMetadata: {name},
			pinataOptions: {
				cidVersion: 1,
				wrapWithDirectory: true,
			},
		});
}

export async function deployNFTGallery(directory: string, name: string, network: string) {
	let imageCid = '';
	const slug = slugify(name);
	return uploadAndPinNFTDirectory(directory, name)
		.then(results => {
			console.log('Image Directory Pinned!', results);
			const { IpfsHash } = results;
			imageCid = IpfsHash;
			const nfts = makeNfts(IpfsHash, network);
			return Promise.all(nfts.map(nft => fs.writeFile(`./metadata/${nft.filename}.json`, JSON.stringify(nft.metadata, null, 2))));
		})
		.then(() => {
			return uploadAndPinNFTDirectory('metadata', `${name} (NFT ${network})`);
		})
		.then(results => {
			console.log('Image Metadata', results);
			const { IpfsHash: metadataCid } = results;
			const outDir = "./deployments/ipfs";
			const deployment = {
				name,
				imageCid,
				metadataCid,
				pieces: galleryPieces,
			};
			return fs
				.stat(outDir)
				.then((stats) => {
					if (!stats.isDirectory()) {
						return fs.mkdir(outDir);
					} else {
						return Promise.resolve();
					}
				})
				.then(() => fs
				.writeFile(`${outDir}/${slug}.json`, JSON.stringify(deployment, null, 2))
				.then(() => fs
				.writeFile('./artifacts/art.ts', `/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { GalleryDeployment } from './types';

export const galleries: GalleryDeployment[] = [${JSON.stringify(deployment, null, 2)}];`)))});
}
